// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel RayMarch

static const float PI = 3.141592653589793;
static const float FAR_PLANE = 100000;

static const float3 DIR_LIGHT = normalize(float3(1, -1, 1));

struct ShapeStruct
{
	float4x4 translateRotateMat;
	float4x4 translateRotateMatInv;
	float3 size;
	float4 color;
	uint id;
};

struct CameraStruct
{
	float3 position;
	float3 right;
	float3 up;
	float3 forward;
};

RWTexture2D<float4> outTexture;

uint2 screenSize;
float tangent;
float aspect;
float epsilon;
float delta;
int maxSteps;

StructuredBuffer<ShapeStruct> shapes;
StructuredBuffer<CameraStruct> camera;
uint shapeCount;

float sphereDE(float3 currPos)
{
	return length(currPos) - 1;
}

float cubeDE(float3 currPos, float3 size)
{
	float3 d = abs(currPos) - size;
	return length(max(d, 0)) + min(max(d.x, max(d.y, d.z)), 0);
}

float tetrahedronDE(float3 currPos)
{
	return 0;
}

float planeDE(float3 currPos, float3 normal)
{
	return dot(currPos, normal);
}

float distanceEstimator(ShapeStruct shapeBuffer, float3 currPos)
{
	currPos = mul(shapeBuffer.translateRotateMatInv, float4(currPos, 1)).xyz;
	if (shapeBuffer.id == 0)
	{
		return sphereDE(currPos/shapeBuffer.size.x)*shapeBuffer.size.x;
	}
	else if (shapeBuffer.id == 1)
	{
		return cubeDE(currPos, shapeBuffer.size);
	}
	else if (shapeBuffer.id == 2)
	{
		return tetrahedronDE(currPos/shapeBuffer.size.x)*shapeBuffer.size.x;
	}
	else if (shapeBuffer.id == 3)
	{
		float3 normal = mul(shapeBuffer.translateRotateMat, float4(0, 1, 0, 0)).xyz;
		return planeDE(currPos, normal);
	}
	else
	{
		return sphereDE(currPos);
	}
}

float4 calculateColor(float3 currPos, float3 camPos, float4 baseColor)
{
	// Normal calculation
	float pdx = 1000000;
	float ndx = 1000000;
	float pdy = 1000000;
	float ndy = 1000000;
	float pdz = 1000000;
	float ndz = 1000000;
	for (uint i = 0; i < shapeCount; i++)
	{
		pdx = min(pdx, distanceEstimator(shapes[i], currPos + float3(delta, 0, 0)));
		ndx = min(ndx, distanceEstimator(shapes[i], currPos - float3(delta, 0, 0)));
		pdy = min(pdy, distanceEstimator(shapes[i], currPos + float3(0, delta, 0)));
		ndy = min(ndy, distanceEstimator(shapes[i], currPos - float3(0, delta, 0)));
		pdz = min(pdz, distanceEstimator(shapes[i], currPos + float3(0, 0, delta)));
		ndz = min(ndz, distanceEstimator(shapes[i], currPos - float3(0, 0, delta)));
	}
	float3 viewDir = normalize(camPos - currPos);
	float3 normal = normalize(float3(pdx - ndx, pdy - ndy, pdz - ndz));
	float3 halfway = normalize(-DIR_LIGHT + viewDir);

	// Ambient
	float3 ambient = 0.2 * baseColor.rgb;

	// Diffuse
	float3 diffuse = saturate(0.8 * dot(normal, -DIR_LIGHT)) * baseColor.rgb;

	// Specular
	float3 specular = 0.6 * pow(abs(dot(normal, halfway)), 30) * float3(1, 1, 1);

	return float4(ambient + diffuse + specular, 1);
}

[numthreads(32,16,1)]
void RayMarch(uint3 id : SV_DispatchThreadID)
{
	// Calculate viewport position
	float2 viewportPos = id.xy / (screenSize-1.0) * 2 - 1;
	viewportPos.x *= aspect;
	viewportPos *= tangent;

	// Create the ray
	float3 direction = float3(0, 0, 0);
	direction += camera[0].right * viewportPos.x;
	direction += camera[0].up * viewportPos.y;
	direction += camera[0].forward;
	direction = normalize(direction);

	// March!
	float3 currPos = camera[0].position;
	float totalDist = 0;
	int s;
	int hitIndex = -1;
	for (s = 0; s < maxSteps; s++)
	{
		// Find smallest distance
		float minDist = 1000000000;
		int index = -1;
		for (uint i = 0; i < shapeCount; i++)
		{
			float dist = distanceEstimator(shapes[i], currPos);
			if (dist < minDist)
			{
				minDist = dist;
				index = i;
			}
		}

		// Move forward
		currPos += minDist * direction;
		totalDist += minDist;

		// Check if hit object
		if (minDist <= epsilon)
		{
			hitIndex = index;
			break;
		}
	}

	if (totalDist <= FAR_PLANE)
	{
		outTexture[id.xy] = calculateColor(currPos, camera[0].position, shapes[hitIndex].color);
		// float grayscale = 1 - float(s)/float(maxSteps);
		// outTexture[id.xy] = float4(grayscale, grayscale, grayscale, 1);
	}
	else
	{
		outTexture[id.xy] = float4(0.2, 0.2, 0.2, 1);
	}
}
